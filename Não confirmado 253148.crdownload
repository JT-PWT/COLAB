# -*- coding: utf-8 -*-
"""Jef3_Desempenho_de_alunos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15VRbNfOQjypBpPKhXu_MMNJjxDtHtUkR
"""

#importar bibliotecas
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from statsmodels.stats.outliers_influence import variance_inflation_factor
from statsmodels.stats.diagnostic import het_breuschpagan
'''heterocedasticidade-teste de Breusch-Pagan - quando temos variância dos erros/resíduos
de um modelo de regressão linear que não é constante em todos os níveis das variáveis
independentes
Hipóteses:
nula: homcedasticidade (variância constante)
alternativa: Heterocedasticidade
'''

#Carregar os dados
df = pd.read_csv('/content/base_desempenho_alunos - base_desempenho_alunos.csv')

#Correlação entre variáveis
plt.figure(figsize=(10,8))
sns.heatmap(df.corr(), annot=True, cmap='coolwarm', fmt='.2f')
plt.title('Matriz de correlação')
plt.show()

#separar variáveis preditoras (x) e variável alvo (y)
x = df.drop(columns='nota_final')
y = df['nota_final']

#adicionar constante para o modelo (intercepto)
x = sm.add_constant(x)

#treinar o modelo com todos os dados (sem sklearn)
#STATSMODEL
modelo = sm.OLS(y,x).fit()
'''statsmodel: quando o objetivo é de efetuar análise estatística e inferência
sklearn: usado pra ML, predição e pipelines'''
#Exibir o resumo do modelo
print(modelo.summary())

#resíduos e valores ajustados
valores_ajustados = modelo.fittedvalues
residuos = modelo.resid

plt.figure(figsize=(10,5))
sns.scatterplot(x=valores_ajustados, y=residuos)
plt.axhline(0, color='red', linestyle='--')
plt.title('Resíduos x Valores Ajustados')
plt.xlabel('Valores Ajustados')
plt.ylabel('Resíduos')
plt.grid(True)
plt.show()

df.describe()

'''Equação gerada:
nota_final =  0.0300 * horas_estudo_semana + 0.0033 *frequencia_percentual +  0.0103 * nota_prova_1 +  0.0083 * nota_prova_2
+  0.0460 * sono_medio + 0.1368 * atividade_fisica + 97.6089'''



"""#Solução com Statsmodel e SciKit Learn"""

#Carregar os dados
df = pd.read_csv('/content/base_desempenho_alunos - base_desempenho_alunos.csv')

#Correlação entre variáveis
plt.figure(figsize=(10,8))
sns.heatmap(df.corr(), annot=True, cmap='coolwarm', fmt='.2f')
plt.title('Matriz de correlação')
plt.show()

#2. Construção do modelo

#Separar x e y
x = df.drop(columns='nota_final')
y = df['nota_final']

#adicionando a constante
x_const = sm.add_constant(x)

#separando dados de treino e teste
x_train, x_test, y_train, y_test = train_test_split(x_const, y, test_size=0.2, random_state=42)

# Recalcular x_train sem a constante pra evitar viés do VIF
x_vif = x_train.drop(columns='const') # criei lá em cima para utilizar apenas no statsmodel

#Calcular o VIF para cada variável = ver se há relação entre as variáveis. Se for colinear, invibializa a regressão linear
vif_data = pd.DataFrame()
vif_data['Variável'] = x_vif.columns
vif_data['VIF'] = [variance_inflation_factor(x_vif.values, i) for i in range(x_vif.shape[1])]
print(vif_data)

#Treinando o modelo
modelo = sm.OLS(y_train, x_train).fit()

#Sumário do modelo
print(modelo.summary())

#Verificação dos pressupostos

#a. residuos
y_train_pred = modelo.predict(x_train)
residuos = y_train - y_train_pred

#b. Resíduos vs Ajustados (homoscedasticidade)
plt.figure(figsize=(10,5))
sns.scatterplot(x=y_train_pred, y=residuos)
plt.axhline(0, color='red', linestyle='--')
plt.title('Resíduos vs Valores Ajustados')
plt.xlabel('Valores Ajustados')
plt.ylabel('Resíduos')
plt.grid(True)
plt.show()

#c. QQ-Plot
sm.qqplot(residuos, line='45', fit=True)
plt.title('QQ Plot dos Resíduos')
plt.grid(True)
plt.show()

#d. Durbin-Watson (independência dos erros)
from statsmodels.stats.stattools import durbin_watson
dw = durbin_watson(residuos)
print(f'Durbin-Watson: {dw:.3f}')

#verificação de resíduos e valores ajustados

#Teste de Breusch-Pagan
bp_test = het_breuschpagan(residuos, x_train)
labels = ['LM Statistic', 'LM p-value', 'F-statistic', 'F p-value Breusch Pagan']

for l, v in zip(labels, bp_test):
  print(f'{l}: {v:.4f}')